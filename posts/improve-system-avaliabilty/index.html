<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css><link rel=icon href=/favicon.ico><title>~/on-the-road</title>
<meta charset=utf-8><meta name=description content="Ladder@提高可用性，应该从全局，而非单点技术考虑（包括研发流程、团队文化等），提升可用性是一个过程，需要长时间的积累。文章简要介绍高可用架构设计关键点，希望对在做系统架构设计的新同学有一点帮助，能够对系统可用性有个整体认知"><meta name=author content="leo9827"><link rel=canonical href=https://leo9827.github.io/posts/improve-system-avaliabilty/><link rel=stylesheet href=/css/main.min.8fdbbc58b1127d24d69251880ba35cc81962e25a734d04a4318c766e02b6f382.css integrity="sha256-j9u8WLESfSTWklGIC6NcyBli4lpzTQSkMYx2bgK284I=" crossorigin=anonymous media=screen><script src=https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.js></script><script src=https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js></script></head><script>pangu.spacingElementById("main"),pangu.spacingElementByClassName("comment"),pangu.spacingElementByTagName("p"),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()}),document.addEventListener("DOMContentLoaded",function(){const s=document.querySelectorAll(".post-card-summary"),t=140;s.forEach(e=>{console.log(e.textContent.length),e.textContent.length>t&&(e.textContent=e.textContent.substring(0,t-1)+" ...")});const n=document.querySelector(".theme-switch"),o='<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>',i='<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>';let e=!1;const a=localStorage.getItem("theme")||"light";a==="dark"&&document.body.classList.add("dark-mode"),n.addEventListener("click",()=>{document.body.classList.toggle("dark-mode"),e=!e,n.innerHTML=`${e?i:o}`;let t="light";document.body.classList.contains("dark-mode")&&(t="dark"),localStorage.setItem("theme",t)});const r=document.querySelectorAll(".post");r.forEach(e=>{const t=e.querySelectorAll("table");t.forEach(e=>{const t=document.createElement("div");t.classList.add("table-container"),e.parentNode.insertBefore(t,e),t.appendChild(e)})})})</script><body><header id=header-main class=header-main><div class=header-inner><div class=header-brand><a href=/>~/</a></div><nav class=header-nav><ul><li><a href=/posts>Posts</a></li><li><a href=/archives>Archives</a></li><li><a href=/tags>Tags</a></li></ul></nav><div class=header-social-icons><a href=#><i class="fab fa-github"></i></a>
<a href=#><i class="fab fa-twitter"></i></a>
<a href=#><i class="fas fa-envelope"></i></a>
<button class=theme-switch><svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentcolor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364-.707-.707M6.343 6.343l-.707-.707m12.728.0-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/></svg></button></div></div></header><main class=wrapper><div id=post class=post><article class=post-single><header class=post-title><h1>提升系统可用性</h1></header><p><small>Post on&nbsp;April 1, 2024&nbsp;
·&nbsp;3689 words&nbsp;
·&nbsp;reading time 2 min</small><p><div class=post-toc><nav id=TableOfContents><ul><li><a href=#1概述>1.概述</a><ul><li><a href=#11-可用性-vs-可靠性>1.1. 可用性 vs 可靠性</a></li><li><a href=#12-可用性减低的原因>1.2. 可用性减低的原因</a></li><li><a href=#13-提升高可用原则>1.3. 提升高可用原则</a></li></ul></li><li><a href=#2-服务发布>2. 服务发布</a><ul><li><a href=#21-成熟机制和流程>2.1. 成熟机制和流程</a></li></ul></li><li><a href=#3-容错设计-design-for-failure>3. 容错设计 Design for failure</a><ul><li><a href=#31-消除单点>3.1. 消除单点</a></li><li><a href=#33-服务分级>3.3. 服务分级</a></li><li><a href=#34-服务降级设计>3.4. 服务降级设计</a></li><li><a href=#35-超时重试>3.5. 超时重试</a></li><li><a href=#36-隔离策略>3.6. 隔离策略</a></li><li><a href=#37-熔断器防止雪崩>3.7. 熔断器（防止雪崩）</a></li></ul></li><li><a href=#4-流控设计过载保护>4. 流控设计（过载保护）</a><ul><li><a href=#41-限流算法>4.1. 限流算法</a></li><li><a href=#42-流控策略>4.2. 流控策略</a></li></ul></li><li><a href=#44-容量预估>4.4. 容量预估</a></li><li><a href=#5-故障演练---chaos>5. 故障演练 - Chaos</a></li><li><a href=#6-数据迁移---目标是zero-downtime>6. 数据迁移 - 目标是Zero Downtime</a></li></ul></nav><br></div><section class=post-content><p>提高可用性，应该从<strong>全局</strong>，而非单点技术考虑（包括研发流程、团队文化等），提升可用性是一个过程，需要长时间的积累。文章简要介绍高可用架构设计关键点，希望对在做系统架构设计的新同学有一点帮助，能够对系统可用性有个整体认知</p><h2 id=1概述>1.概述</h2><p><em><strong>架构设计一个处理软件复杂度的过程，同时应该遵循TradeOff原则，结合项目实际情况落地增强系统可用性</strong></em></p><h3 id=11-可用性-vs-可靠性>1.1. 可用性 vs 可靠性</h3><ul><li>可用性(N个9表述): 系统可用的时间，以丢失的时间为驱动，公式: <code>PA=Uptime/(Uptime+Downtime)</code></li><li><code>Uptime</code>: 系统可用时间</li><li><code>Downtime</code>: 系统不可用时间</li><li>可靠性: 系统无失效时间间隔，以发生的失效个数作为驱动，公式: <code>PA=MTBF/(MTBF+MTTR）</code></li><li><code>MTBF</code>: 平均故障时间(mean time between faiulre)</li><li><code>MTTR</code>: 平均故障修复时间(mean time to repair)</li></ul><p><strong>可用性等级:</strong></p><table><thead><tr><th>等级</th><th>几个9</th><th>年停机时长</th><th>常用技术</th></tr></thead><tbody><tr><td>基本可用</td><td>99%</td><td>87.6h</td><td>负载均衡</td></tr><tr><td>较高可用</td><td>99.9%</td><td>8.8h</td><td>灰度发布、快速回滚、自动化发布</td></tr><tr><td>高级可用</td><td>99.99%</td><td>53min</td><td>微服务、数据库、缓存集群、容错、监控、弹性伸缩</td></tr><tr><td>极高可用</td><td>99.999%</td><td>5min</td><td>异地多活、智能运维</td></tr></tbody></table><h3 id=12-可用性减低的原因>1.2. 可用性减低的原因</h3><ul><li>发布: 服务升级、数据迁移导致服务可能中断，<strong>80%的故障是由于发布造成的</strong></li><li>故障: 服务Bug、系统宕机、内存溢出、网络波动等导致服务可能中断</li><li>压力: 突发事件导致服务处理不过来，导致服务中断</li><li>外部依赖： 外部依赖服务故障，导致调用异常</li></ul><h3 id=13-提升高可用原则>1.3. 提升高可用原则</h3><ul><li><strong>20/10/5原则</strong>，提升系统架构高可用的上限</li><li><strong>Design for fail原则</strong>，提升系统韧性</li><li><strong>知己知彼原则</strong>，提升系统透明度，识别系统潜在风险，提前做好预案</li></ul><h2 id=2-服务发布>2. 服务发布</h2><blockquote><p>思考切尔诺贝利事件，流程操作规范的重要性</p></blockquote><p><strong>发布关注点</strong>:</p><ul><li>发布流程CheckList、CR</li><li>发布策略: 错峰、灰度流量逐步放开</li><li>回滚策略: 异常问题及时回滚</li><li>运维值守</li></ul><h3 id=21-成熟机制和流程>2.1. 成熟机制和流程</h3><h4 id=211-蓝绿部署>2.1.1. 蓝绿部署</h4><p>部署蓝绿两套集群，通过负载均衡关联，新旧蓝绿交替滚动发布，回退简单，负载均衡切换到旧版本即可（<strong><em>当存在数据隔离后，实际情况操作比较复杂</em></strong>），相关特点：</p><ul><li>自动化基础设施依赖</li><li>全面监控</li><li>两套环境隔离，有相互影响风险（比如: 存储服务无法很好蓝绿处理）</li><li>难点数据结构变更，如何同步数据，故障时候，如何回滚</li><li>支持流量快速切换（实际有困难）</li></ul><h4 id=212-灰度发布金丝雀发布>2.1.2. 灰度发布/金丝雀发布</h4><ul><li>流程:从负载均衡剔除节点(流量踢干净)、节点升级、自动化接口测试、加入负载均衡、监控故障、逐步灰度其他节点</li><li>意义:减少故障范围、尽早用户反馈和数据收集</li><li>灰度控制:<strong>内部->外部1%->5%->10%->全网</strong></li></ul><h2 id=3-容错设计-design-for-failure>3. 容错设计 Design for failure</h2><blockquote><p>容错设计是为了确保错误发生时，能够从容应对</p></blockquote><h3 id=31-消除单点>3.1. 消除单点</h3><ol><li>服务冗余设计</li><li>服务无状态</li><li>故障转移（比如nginx+keepalive、redis哨兵、mysql主从切换）</li></ol><h3 id=33-服务分级>3.3. 服务分级</h3><blockquote><p>产品功能梳理核心流程，找到核心服务，划分等级，确认服务关键程度</p></blockquote><table><thead><tr><th>服务级别</th><th>划分依据</th><th>示例</th></tr></thead><tbody><tr><td>1级服务</td><td>核心业务流程，一旦故障业务遭受重大损失</td><td>注册、登录、支付</td></tr><tr><td>2级服务</td><td>用户体验影响严重，一旦故障，关键业务还可用，用户体验影响严重</td><td>搜索、评论</td></tr><tr><td>3级服务</td><td>用户体验影响轻微，一旦故障，正常流程不受影响，不常用的功能不可用</td><td>个人信息</td></tr><tr><td>4级服务</td><td>多为管理维护，用户不受影响，用户不会直接访问</td><td>统计、排行</td></tr></tbody></table><h3 id=34-服务降级设计>3.4. 服务降级设计</h3><ol><li>服务降级前置条件是先梳理清楚服务核心等级，预先配置中心定义好降级开关</li><li>降级方式<ul><li><strong>关闭功能</strong>: 业务JS控制少掉了某个功能</li><li><strong>请求短路</strong>：返回缓存数据</li><li>简化流程：注册成功的提示短信不发</li><li>延迟执行: 比如定时任务</li><li>关闭定时任务</li><li><strong>低精确度返回</strong>：比如报名人数、在线人数</li></ul></li></ol><h3 id=35-超时重试>3.5. 超时重试</h3><p>主调服务请求被动服务，可能存在成功、失败、超时3类状态，频繁发起重试，可能加重消费者负担，造成更严重的事故。</p><p>重试策略的关键因子:</p><ol><li>超时时间: 包括调用超时时间、下游服务处理时间</li><li>重试总次数（retrycount）：多次重试可能对下游造成更大压力</li><li>重试间隔时间（intervalTimey）：间隔多久重试</li><li>重试间隔时间衰减（weakTime）: 时间退避/衰减算法</li></ol><p>重试模式：</p><ol><li><strong>简单重试</strong>：try-catch-redo，重试一次</li><li><strong>策略重试</strong>: try-catch-redo-retry straegy，重试策略决定是否重试，关键因子(retrycount、intervalTimey、weakTime)</li></ol><p>重试模式比较通用，尝试对业务解耦</p><ul><li>何种条件重试: 符合指定策略才重试</li><li>何时重试: 立即重试、间隔重试、时间衰减重试、随机退避重试</li><li>重试次数：不超过重试次数最大限度重试</li></ul><h3 id=36-隔离策略>3.6. 隔离策略</h3><ul><li>进程、线程池</li><li>机器隔离</li><li>集群隔离</li><li>地域隔离</li><li>用户、租户隔离</li></ul><h3 id=37-熔断器防止雪崩>3.7. 熔断器（防止雪崩）</h3><blockquote><p>服务雪崩：服务提供者的不可用导致服务消费者也不可用，并将不可用逐级放大的过程。<br>熔断器就是放在主调服务一侧，阻断主调请求避免对下游服务提供者造成压力。当被调大量超时下，主调服务主动熔断，防止服务进一步拖垮，一旦情况变好，主调重新尝试，最终让系统恢复</p></blockquote><p>熔断器三种状态：</p><ul><li>打开: 断路状态，调用请求被禁止，快速失败/业务降级返回</li><li>闭合: 通路状态，调用请求被允许放行；当在闭合下，区间时间内累计错误次数达到阈值，则将闭合状态变为打开状态，服务被熔断</li><li>半打开：熔断器允许部分请求到达下游，当在半打开下，若依旧有调用失败，则返回打开状态；若请求顺利，调用成功，则返回到闭合状态</li></ul><p>注意:</p><ol><li>禁止一个熔断器控制多个服务</li><li>熔断后，主调方应该做好快速失败、业务降级、不显示/显示缓存值返回</li><li>任务干预，支持通过开关预留，这次手动强制开启或关闭熔断器</li></ol><h2 id=4-流控设计过载保护>4. 流控设计（过载保护）</h2><blockquote><p>流控，通过流量控制保护服务自身免被压垮，起到超出部分被拒绝，承受范围内请求被正常处理</p></blockquote><h3 id=41-限流算法>4.1. 限流算法</h3><h4 id=411-固定窗口fixed-window>4.1.1. 固定窗口(fixed window)</h4><p>每个时间片内窗口内，允许访问的总次数。</p><p>缺点是算法存在临界值2倍限流量情况，同时在下个时间片内出容易现流量蜂拥，容易形成踩踏现象</p><h4 id=412-漏桶算法leaky-bucket>4.1.2. 漏桶算法(Leaky Bucket)</h4><ul><li>水流入(请求生产): 漏入桶中，桶满则溢出</li><li>漏桶(队列): FIFO队列</li><li>水流出(请求消费): 以一定速率从桶内取出请求消费</li></ul><p>适用场景: 秒杀场景，削峰填谷</p><h4 id=413-令牌桶算法token-buket>4.1.3. 令牌桶算法(Token Buket)</h4><blockquote><p>一个时间窗口内通过的数据量，通过以QPS、TPS衡量</p></blockquote><ol><li>创建一个可放指定数量(M)令牌的桶（队列）</li><li>每间隔一定时间片，放入一个令牌到桶中（定时令牌生成器），桶满则溢出</li><li>每当R个请求到达时，从桶内取出min(M,R)个令牌，若桶内令牌不够，则将请求缓存或者丢弃（对比网卡的环形队列作用）</li></ol><h3 id=42-流控策略>4.2. 流控策略</h3><blockquote><p>需要配合压测结果、资源环境，对每个服务单独进行配置，一般采用经验值</p></blockquote><p>流控的几点注意:</p><ol><li>尽量在请求入口处做收拢，比如GW层(nginx)、业务出入口、公共基础服务</li><li>流控阈值可能会随着服务的迭代也会变化，比如迭代后服务耗时增加了，那么对应的流控速率就应该更小了，这点需要注意</li><li>阈值不要设置过大，否则起不到流控作用</li></ol><h2 id=44-容量预估>4.4. 容量预估</h2><blockquote><p>对系统容量做到知根知底，ab、LoadRunner、Jmeter这类都比较片面，很难系统模拟生产环境数据，采用全链路可以规避这些问题</p></blockquote><p>全链路压测进行容量评估，几点注意:</p><ol><li>核心流程：28原则，确保真正核心的流程被压测到，这里就需要有张整体的服务调用网络拓扑图，并梳理出核心链路</li><li>隔离方式：独立压测环境，压测效果和隔离效果好，但成本高；生产混合，通过参数识别，在框架和服务处染色处理，资源隔离性不好；</li><li>缩小依赖范围：这样可以更加有的放矢，识别链路的关键瓶颈</li></ol><p>PS: 链路有短板效应，需要准确的识别到链路的短板，方便后期做好性能提升，增加系统整体吞吐</p><h2 id=5-故障演练---chaos>5. 故障演练 - Chaos</h2><blockquote><p>The best way to avoid failure is to fail constantly</p></blockquote><p>故障演练可以检测业务应用处理失败的能力，以及团队对故障的应对反应(包括通过监控日志、快速故障定位、应急措施），避免当故障真正发生时候，团队人员手忙脚乱，不知所措。</p><h2 id=6-数据迁移---目标是zero-downtime>6. 数据迁移 - 目标是Zero Downtime</h2><p>做数据迁移时候，也可能对系统可用性有影响，目标是无停机时间，常见迁移方式：</p><ul><li>逻辑分离，物理不分离<ul><li>新老服务，双写同一个数据库/缓存不同表</li><li>过渡方案</li></ul></li><li>逻辑分析力，物理分离<ul><li>需要做数据同步，比如通过工具读取binlog实现数据双向同步</li><li>业务应用同时写两个库</li><li>老系统写消息通过写到消息中间件，消费消息中间件实现同步</li></ul></li></ul><p>关键问题: 数据一致性问题</p></section><br><p><small>Post on&nbsp;April 1, 2024&nbsp;
·&nbsp;248 words&nbsp;</small><p><hr><div class=page-nav><a class=page-next href=https://leo9827.github.io/posts/my-study-method/><span>我的学习方法</span>
&nbsp;&nbsp;<i class="fa-solid fa-arrow-right"></i></a></div></article></div><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelector(".page-nav");console.log(e.childElementCount);const t=e.firstElementChild.classList.contains("page-next");t?e.classList.add("first-page"):e.classList.remove("first-page");const n=e.childElementCount===1&&e.firstElementChild.classList.contains("page-prev");n?e.classList.add("last-page"):e.classList.remove("last-page")})</script></main><footer><p>&copy; 2024 Personal Site. All rights reserved.</p></footer></body><script></script></html>